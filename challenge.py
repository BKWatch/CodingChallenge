# -*- coding: utf-8 -*-
"""test.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/198F1FSPcHVgXGhosNzOChwV02pmekBD8
"""

import argparse
import sys
import os
import csv
import xml.etree.ElementTree as ET
import re

def is_valid_extension(fp, valid_exts):
  _, file_ext = os.path.splitext(fp)
  file_ext = file_ext[1:].lower()
  return file_ext in valid_exts

def parse_arguments():
  parser = argparse.ArgumentParser(description="process xml, tsv, and txt files into a standard format.")
  parser.add_argument('files', nargs='+', help='list of files to process')
  return parser.parse_args().files

def xml2dict(fp):
  import re
  import xml.etree.ElementTree as ET

  valid_keys = {"name", "street", "county", "organization", "city", "state", "zip"}
  key_map = {'postal_code': 'zip'}

  tree = ET.parse(fp)
  root = tree.getroot()
  entities = root.find('ENTITY')
  all_entities = []
  all_keys = set()
  for ent in entities.findall('ENT'):
    entity_dict = {}
    for child in ent:
      key = child.tag.lower()
      mapped_key = key_map.get(key, key)
      if child.text and mapped_key in valid_keys:
        text = child.text.strip()
        if mapped_key == 'zip':
          text = re.sub(r'\s*-\s*$', '', text)  # remove dash and whitespace
          text = re.sub(r'\s+', '', text)  # remove remaining spaces
        entity_dict[mapped_key] = text
    all_keys.update(entity_dict.keys())
    all_entities.append(entity_dict)
  # print("keys in xml:", all_keys)
  return all_entities

def parse_txt_line(line, entry):
  import re
  if ',' in line and 'street' not in entry:
    parts = line.split(',')
    potential_name = parts[0].strip()
    if any(char.isdigit() for char in potential_name):
      entry['street'] = line
    else:
      entry['name'] = potential_name
  elif any(ext.isdigit() for ext in line) and 'zip' not in entry:
    zip_code_search = re.search(r'\d{5}(?:-\d{4})?$', line)
    if zip_code_search:
      entry['zip'] = zip_code_search.group()
      line = line[:zip_code_search.start()].strip()
    if 'street' not in entry:
      entry['street'] = line
    else:
      entry['city'] = line.split(',')[0]
  elif 'county' not in entry:
    entry['county'] = line

def tsv2dict(fp):
  valid_keys = {"name", "street", "county", "organization", "city", "state", "zip"}
  with open(fp, 'r', newline='') as file:
    reader = csv.DictReader(file, delimiter='\t')
    data = [{key: row[key].strip() for key in row if key in valid_keys} for row in reader]
  return data

def txt2dict(fp):
  valid_keys = {"name", "street", "county", "organization", "city", "state", "zip"}
  dictionary_list = []
  with open(fp, "r") as file:
    entry = {}
    for line in file:
      line = line.strip()
      if not line and entry:
        dictionary_list.append({key: entry[key] for key in entry if key in valid_keys})
        entry = {}
      else:
        parse_txt_line(line, entry)
    if entry:
      dictionary_list.append({key: entry[key] for key in entry if key in valid_keys})
  return dictionary_list

def parse_arguments():
    parser = argparse.ArgumentParser(description="process xml, tsv, and txt files into a unified format.")
    parser.add_argument('files', nargs='+', help='list of files to process')
    args = parser.parse_args()
    return args.files

def process_files(files):
  valid_exts = {"tsv", "txt", "xml"}
  json_files = []

  for f in files:
    if is_valid_extension(f, valid_exts):
      try:
        file_type = f.split('.')[-1]
        if file_type == "tsv":
          json_files.extend(tsv2dict(f))
        elif file_type == "txt":
          json_files.extend(txt2dict(f))
        elif file_type == "xml":
          json_files.extend(xml2dict(f))
      except Exception as e:
        print(f"error processing {f}: {str(e)}", file=sys.stderr)
        return None
    else:
      print(f"unsupported file type for {f}", file=sys.stderr)
      return None

  return json_files

def main():
  try:
    files = parse_arguments()
    json_files = process_files(files)
    if json_files is not None:
      print(json_files)
      return 0
    else:
      return 1
  except Exception as e:
    print(f"unexpected error: {e}", file=sys.stderr)
    return 1

if __name__ == "__main__":
  sys.argv = ['test.py', 'input1.xml', 'input2.tsv', 'input3.txt']
  exit_status = main()
  print(f"exit status: {exit_status}")

